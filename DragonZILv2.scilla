scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import BoolUtils PairUtils ListUtils
library DragonZIL

(* User-defined ADTs *)
type Dummy =
| Dummy

type Operation =
| Add
| Sub

(* DragonZIL types *)
(* Custom ADT storing - token_id, owner, stage, token_uri, token_gen_battle, token_gen_image *)
type Dragon =
| Dragon of Uint256 ByStr20 Uint32 String Uint256 Uint256

(* Custom ADT storing - token_id, token_gen_battle *)
type IdBattleGenPair =
| IdBattleGenPair of Uint256 Uint256
(* DragonZIL types *)

(* Global variables *)
let zero = Uint256 0
let one = Uint256 1
let verdad = Dummy
let add_operation = Add
let sub_operation = Sub

let zero_address = 0x0000000000000000000000000000000000000000
let dummy_str = ""
let default_stage = Uint32 0
let zero = Uint256 0
let one = Uint256 1
let two = Uint256 2
let three = Uint256 3
let four = Uint256 4
let five = Uint256 5
let six = Uint256 6
let seven = Uint256 7
let eight = Uint256 8
let nine = Uint256 9
let ten = Uint256 10
let ten2 = Uint256 100
let ten3 = Uint256 1000

(* Library functions *)
let one_msg = 
  fun (msg : Message) => 
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let two_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
    let msgs_tmp = one_msg msg2 in
    Cons {Message} msg1 msgs_tmp

let get_bal =
  fun (some_bal: Option Uint256) =>
    match some_bal with
    | Some bal => bal
    | None => zero
    end

let option_value =
  tfun 'A =>
  fun (default: 'A) =>
  fun (opt_val: Option 'A) =>
    match opt_val with
    | Some v => v
    | None => default
    end

let random =
  fun (entropy: Uint256) =>
  fun (block_number: BNum) =>
  fun (addr: ByStr20) =>
    let addr_hash = builtin keccak256hash addr in
    let entropy_hash = builtin keccak256hash entropy in
    let blockhash = builtin keccak256hash block_number in
    let ehash = builtin concat entropy_hash blockhash in
    let ahash = builtin concat ehash addr_hash in
    let last_hash = builtin concat ehash ahash in
    let hash = builtin keccak256hash last_hash in
      builtin to_uint256 hash

let calc_gens_tmp_new =
  fun (old_val: Uint256) =>
  fun (gen_num: Uint256) =>
  fun (check_with: Uint256) =>
  fun (val: Uint256) =>
    let gen_bool = builtin eq gen_num check_with in
    match gen_bool with
    | True => val
    | False => old_val
    end

let calc_gens_2opt_do =
  fun (gen_num: Uint256) =>
  fun (val1: Uint256) =>
  fun (val2: Uint256) =>
    let gen_bool = builtin lt gen_num five in
    match gen_bool with
    | True => val1
    | False => val2
    end

let calc_gens_2opt =
  fun (old_val: Uint256) =>
  fun (gen_num: Uint256) =>
  fun (check_with: Uint256) =>
  fun (gen_num2: Uint256) =>
  fun (val1: Uint256) =>
  fun (val2: Uint256) =>
    let gen_bool = builtin eq gen_num check_with in
    match gen_bool with
    | True => calc_gens_2opt_do gen_num2 val1 val2
    | False => old_val
    end

let option_address = @option_value ByStr20
let option_str = @option_value String
let option_uint32 = @option_value Uint32
let option_uint256 = @option_value Uint256
let option_uint128 = @option_value Uint128

let build_dragon =
  fun (token_id: Uint256) =>
  fun (some_token_owner: Option ByStr20) =>
  fun (some_token_uri: Option String) =>
  fun (some_token_gen_battle: Option Uint256) =>
  fun (some_token_gen_image: Option Uint256) =>
  fun (some_token_stage: Option Uint32) =>
    let owner = option_address zero_address some_token_owner in
    let uri = option_str dummy_str some_token_uri in
    let gen_battle = option_uint256 zero some_token_gen_battle in
    let gen_image = option_uint256 zero some_token_gen_image in
    let stage = option_uint32 default_stage some_token_stage in
      Dragon token_id owner stage uri gen_battle gen_image

(* Error exception *)
type Error =
  | CodeNotContractOwner
  | CodeIsSelf
  | CodeTokenExists
  | CodeIsNotMinter
  | CodeNotApproved
  | CodeNotTokenOwner
  | CodeNotFound
  | CodeNotApprovedForAll
  | CodeNotOwnerOrOperator
  | CodeNotApprovedSpenderOrOperator
  | CodeNotOwnerOrOperatorOrApprovedSpender
  | CodeStageError
  | CodeListEmpty

let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | CodeNotContractOwner             => Int32 -1
      | CodeIsSelf                       => Int32 -2
      | CodeTokenExists                  => Int32 -3
      | CodeIsNotMinter                  => Int32 -4
      | CodeNotApproved                  => Int32 -5
      | CodeNotTokenOwner                => Int32 -6
      | CodeNotFound                     => Int32 -7
      | CodeNotApprovedForAll            => Int32 -8
      | CodeNotOwnerOrOperator           => Int32 -9
      | CodeNotApprovedSpenderOrOperator => Int32 -10
      | CodeNotOwnerOrOperatorOrApprovedSpender => Int32 -11
      | CodeStageError                   => Int32 -12
      | CodeListEmpty                    => Int32 -13
      
      end
    in
    { _exception : "Error"; code : result_code }

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract DragonZIL
(
  contract_owner: ByStr20,
  name : String,
  symbol: String
)

(* Mutable fields *)

(* DragonZIL fields *)
field entropy : Uint256 = Uint256 0
field max_stage : Uint32 = Uint32 1

field token_gen_battle: Map Uint256 Uint256 = Emp Uint256 Uint256
field token_gen_image: Map Uint256 Uint256 = Emp Uint256 Uint256

field token_id_count: Uint256 = Uint256 0

field tmp: List (Dragon) = Nil {Dragon}

field cloud: String = ""
field format_img: String = ".png"
field token_stage: Map Uint256 Uint32 = Emp Uint256 Uint32
field tokens_owner_stage: Map ByStr20 (Map Uint256 Uint32)
  = Emp ByStr20 (Map Uint256 Uint32)
(* DragonZIL fields *)

(* Mapping of minters available *)
field minters: Map ByStr20 Dummy =
    let emp_map = Emp ByStr20 Dummy in
    builtin put emp_map contract_owner verdad

(* Mapping between token_id to token_owner *)
field token_owners: Map Uint256 ByStr20 = Emp Uint256 ByStr20

(* Mapping from owner to number of owned tokens *)
field owned_token_count: Map ByStr20 Uint256 = Emp ByStr20 Uint256

(* Mapping between token_id to approved address                              *)
(* @dev: There can only be one approved address per token at any given time. *)
field token_approvals: Map Uint256 ByStr20 = Emp Uint256 ByStr20

(* Mapping of token_owner to operator  *)
field operator_approvals: Map ByStr20 (Map ByStr20 Dummy)
                            = Emp ByStr20 (Map ByStr20 Dummy)

(* Mapping from token_id to token_uri *)
field token_uris: Map Uint256 String = Emp Uint256 String

(* Total token count *)
field total_supply: Uint256 = Uint256 0

(* DragonZIL procedures *)
procedure ChangeTokenURI(token_id: Uint256, stage: Uint32)
  cloud_url <- cloud;
  format <- format_img;
  separate = "_";

  stage_as_astring = builtin to_string stage;
  stage_separate = builtin concat stage_as_astring separate;
  number_of_token = builtin to_string token_id;
  id_name = builtin concat stage_separate number_of_token;
  token_image_name = builtin concat id_name format;
  token_uri = builtin concat cloud_url token_image_name;

  (* Add token_uri for token_id *)
  token_uris[token_id] := token_uri
end

procedure GenerateImageGen(token_id: Uint256, random_val: Uint256)
  random = random_val;
  (* gens init for current token *)
  gens_image_ = Uint256 777;
  gen_tmp = Uint256 0;

  (* image gen Aura - 5 types *)
  gen_rand = builtin rem random ten;
  gen = calc_gens_tmp_new gen_tmp gen_rand zero zero;
  gen = calc_gens_tmp_new gen gen_rand one zero;
  gen = calc_gens_tmp_new gen gen_rand two zero;
  gen = calc_gens_tmp_new gen gen_rand three zero;
  gen = calc_gens_tmp_new gen gen_rand four one;
  gen = calc_gens_tmp_new gen gen_rand five one;
  gen = calc_gens_tmp_new gen gen_rand six one;
  gen = calc_gens_tmp_new gen gen_rand seven two;
  gen = calc_gens_tmp_new gen gen_rand eight three;

  (* 5prc cases *)
  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;
  gen_rand2 = builtin rem random ten;
  gen = calc_gens_2opt gen gen_rand nine gen_rand2 four five;
  gen_rand = gen_rand2;

  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;

  i = builtin mul gens_image_ ten;
  i2 = builtin add i gen;
  gens_image_ = i2;

  (* image gen Color Aura *)
  gen_rand = builtin rem random ten;
  gen = builtin div gen_rand two;
  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;

  i = builtin mul gens_image_ ten;
  i2 = builtin add i gen;
  gens_image_ = i2;

  (* image gen Horns - 7 types *)
  gen_rand = builtin rem random ten;
  gen = calc_gens_tmp_new gen_tmp gen_rand zero zero;
  gen = calc_gens_tmp_new gen gen_rand one zero;
  gen = calc_gens_tmp_new gen gen_rand two zero;
  gen = calc_gens_tmp_new gen gen_rand three one;
  gen = calc_gens_tmp_new gen gen_rand four one;
  gen = calc_gens_tmp_new gen gen_rand five two;
  gen = calc_gens_tmp_new gen gen_rand six three;
  gen = calc_gens_tmp_new gen gen_rand seven four;
  gen = calc_gens_tmp_new gen gen_rand eight five;

  (* 5prc cases *)
  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;
  gen_rand2 = builtin rem random ten;
  gen = calc_gens_2opt gen gen_rand nine gen_rand2 six seven;
  gen_rand = gen_rand2;

  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;

  i = builtin mul gens_image_ ten;
  i2 = builtin add i gen;
  gens_image_ = i2;

  (* image gen Color Horns *)
  gen_rand = builtin rem random ten;
  gen = builtin div gen_rand two;
  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;

  i = builtin mul gens_image_ ten;
  i2 = builtin add i gen;
  gens_image_ = i2;

  (* image gen Scales - 4 types *)
  gen_rand = builtin rem random ten;
  gen = calc_gens_tmp_new gen_tmp gen_rand zero zero;
  gen = calc_gens_tmp_new gen gen_rand one zero;
  gen = calc_gens_tmp_new gen gen_rand two zero;
  gen = calc_gens_tmp_new gen gen_rand three zero;
  gen = calc_gens_tmp_new gen gen_rand four one;
  gen = calc_gens_tmp_new gen gen_rand five one;
  gen = calc_gens_tmp_new gen gen_rand six one;
  gen = calc_gens_tmp_new gen gen_rand seven two;
  gen = calc_gens_tmp_new gen gen_rand eight two;

  (* 5prc cases *)
  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;
  gen_rand2 = builtin rem random ten;
  gen = calc_gens_2opt gen gen_rand nine gen_rand2 three four;
  gen_rand = gen_rand2;

  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;

  i = builtin mul gens_image_ ten;
  i2 = builtin add i gen;
  gens_image_ = i2;

  (* image gen Color Scales *)
  gen_rand = builtin rem random ten;
  gen = builtin div gen_rand two;
  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;

  i = builtin mul gens_image_ ten;
  i2 = builtin add i gen;
  gens_image_ = i2;

  (* image gen Spots - 9 types *)
  gen_rand = builtin rem random ten;
  gen = calc_gens_tmp_new gen_tmp gen_rand zero zero;
  gen = calc_gens_tmp_new gen gen_rand one one;
  gen = calc_gens_tmp_new gen gen_rand two one;
  gen = calc_gens_tmp_new gen gen_rand three two;
  gen = calc_gens_tmp_new gen gen_rand four three;
  gen = calc_gens_tmp_new gen gen_rand five four;
  gen = calc_gens_tmp_new gen gen_rand six five;
  gen = calc_gens_tmp_new gen gen_rand seven six;
  gen = calc_gens_tmp_new gen gen_rand eight seven;

  (* 5prc cases *)
  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;
  gen_rand2 = builtin rem random ten;
  gen = calc_gens_2opt gen gen_rand nine gen_rand2 eight nine;
  gen_rand = gen_rand2;

  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;

  i = builtin mul gens_image_ ten;
  i2 = builtin add i gen;
  gens_image_ = i2;

  (* image gen Color Spots *)
  gen_rand = builtin rem random ten;
  gen = builtin div gen_rand two;
  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;

  i = builtin mul gens_image_ ten;
  i2 = builtin add i gen;
  gens_image_ = i2;

  (* image gen Tail - 8 types *)
  gen_rand = builtin rem random ten;
  gen = calc_gens_tmp_new gen_tmp gen_rand zero zero;
  gen = calc_gens_tmp_new gen gen_rand one one;
  gen = calc_gens_tmp_new gen gen_rand two one;
  gen = calc_gens_tmp_new gen gen_rand three one;
  gen = calc_gens_tmp_new gen gen_rand four two;
  gen = calc_gens_tmp_new gen gen_rand five three;
  gen = calc_gens_tmp_new gen gen_rand six four;
  gen = calc_gens_tmp_new gen gen_rand seven five;
  gen = calc_gens_tmp_new gen gen_rand eight six;

  (* 5prc cases *)
  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;
  gen_rand2 = builtin rem random ten;
  gen = calc_gens_2opt gen gen_rand nine gen_rand2 seven eight;
  gen_rand = gen_rand2;

  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;

  i = builtin mul gens_image_ ten;
  i2 = builtin add i gen;
  gens_image_ = i2;

  (* image gen Color Tail *)
  gen_rand = builtin rem random ten;
  gen = builtin div gen_rand two;
  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;

  i = builtin mul gens_image_ ten;
  i2 = builtin add i gen;
  gens_image_ = i2;

  (* image gen Wings - 5 types *)
  gen_rand = builtin rem random ten;
  gen = calc_gens_tmp_new gen_tmp gen_rand zero zero;
  gen = calc_gens_tmp_new gen gen_rand one zero;
  gen = calc_gens_tmp_new gen gen_rand two zero;
  gen = calc_gens_tmp_new gen gen_rand three one;
  gen = calc_gens_tmp_new gen gen_rand four one;
  gen = calc_gens_tmp_new gen gen_rand five one;
  gen = calc_gens_tmp_new gen gen_rand six two;
  gen = calc_gens_tmp_new gen gen_rand seven two;
  gen = calc_gens_tmp_new gen gen_rand eight three;

  (* 5prc cases *)
  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;
  gen_rand2 = builtin rem random ten;
  gen = calc_gens_2opt gen gen_rand nine gen_rand2 four five;
  gen_rand = gen_rand2;

  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;

  i = builtin mul gens_image_ ten;
  i2 = builtin add i gen;
  gens_image_ = i2;

  (* image gen Color Wings *)
  gen_rand = builtin rem random ten;
  gen = builtin div gen_rand two;
  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;

  i = builtin mul gens_image_ ten;
  i2 = builtin add i gen;
  gens_image_ = i2;

  (* image gen Spins - 4 types *)
  gen_rand = builtin rem random ten;
  gen = calc_gens_tmp_new gen_tmp gen_rand zero zero;
  gen = calc_gens_tmp_new gen gen_rand one zero;
  gen = calc_gens_tmp_new gen gen_rand two zero;
  gen = calc_gens_tmp_new gen gen_rand three one;
  gen = calc_gens_tmp_new gen gen_rand four one;
  gen = calc_gens_tmp_new gen gen_rand five two;
  gen = calc_gens_tmp_new gen gen_rand six two;
  gen = calc_gens_tmp_new gen gen_rand seven two;
  gen = calc_gens_tmp_new gen gen_rand eight two;

  (* 5prc cases *)
  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;
  gen_rand2 = builtin rem random ten;
  gen = calc_gens_2opt gen gen_rand nine gen_rand2 three four;
  gen_rand = gen_rand2;

  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;

  i = builtin mul gens_image_ ten;
  i2 = builtin add i gen;
  gens_image_ = i2;

  (* image gen Color Spins *)
  gen_rand = builtin rem random ten;
  gen = builtin div gen_rand two;
  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;

  i = builtin mul gens_image_ ten;
  i2 = builtin add i gen;
  gens_image_ = i2;

  (* image gen Body - 3 types *)
  gen_rand = builtin rem random ten;
  gen = calc_gens_tmp_new gen_tmp gen_rand zero one;
  gen = calc_gens_tmp_new gen gen_rand one one;
  gen = calc_gens_tmp_new gen gen_rand two one;
  gen = calc_gens_tmp_new gen gen_rand three one;
  gen = calc_gens_tmp_new gen gen_rand four one;
  gen = calc_gens_tmp_new gen gen_rand five one;
  gen = calc_gens_tmp_new gen gen_rand six one;
  gen = calc_gens_tmp_new gen gen_rand seven one;
  gen = calc_gens_tmp_new gen gen_rand eight one;

  (* 5prc cases *)
  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;
  gen_rand2 = builtin rem random ten;
  gen = calc_gens_2opt gen gen_rand nine gen_rand2 two three;
  gen_rand = gen_rand2;

  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;

  i = builtin mul gens_image_ ten;
  i2 = builtin add i gen;
  gens_image_ = i2;

  (* image gen Color Body *)
  gen_rand = builtin rem random ten;
  gen = builtin div gen_rand two;
  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;

  i = builtin mul gens_image_ ten;
  i2 = builtin add i gen;
  gens_image_ = i2;

  (* image gen Eyes - 9 types *)
  gen_rand = builtin rem random ten;
  gen = calc_gens_tmp_new gen_tmp gen_rand zero one;
  gen = calc_gens_tmp_new gen gen_rand one one;
  gen = calc_gens_tmp_new gen gen_rand two one;
  gen = calc_gens_tmp_new gen gen_rand three two;
  gen = calc_gens_tmp_new gen gen_rand four three;
  gen = calc_gens_tmp_new gen gen_rand five four;
  gen = calc_gens_tmp_new gen gen_rand six five;
  gen = calc_gens_tmp_new gen gen_rand seven six;
  gen = calc_gens_tmp_new gen gen_rand eight seven;

  (* 5prc cases *)
  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;
  gen_rand2 = builtin rem random ten;
  gen = calc_gens_2opt gen gen_rand nine gen_rand2 eight nine;
  gen_rand = gen_rand2;

  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;

  i = builtin mul gens_image_ ten;
  i2 = builtin add i gen;
  gens_image_ = i2;

  (* image gen Color Eyes *)
  gen_rand = builtin rem random ten;
  gen = builtin div gen_rand two;
  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;

  i = builtin mul gens_image_ ten;
  i2 = builtin add i gen;
  gens_image_ = i2;

  (* image gen Head - 5 types *)
  gen_rand = builtin rem random ten;
  gen = calc_gens_tmp_new gen_tmp gen_rand zero one;
  gen = calc_gens_tmp_new gen gen_rand one one;
  gen = calc_gens_tmp_new gen gen_rand two one;
  gen = calc_gens_tmp_new gen gen_rand three one;
  gen = calc_gens_tmp_new gen gen_rand four one;
  gen = calc_gens_tmp_new gen gen_rand five one;
  gen = calc_gens_tmp_new gen gen_rand six one;
  gen = calc_gens_tmp_new gen gen_rand seven two;
  gen = calc_gens_tmp_new gen gen_rand eight three;

  (* 5prc cases *)
  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;
  gen_rand2 = builtin rem random ten;
  gen = calc_gens_2opt gen gen_rand nine gen_rand2 four five;
  gen_rand = gen_rand2;

  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;

  i = builtin mul gens_image_ ten;
  i2 = builtin add i gen;
  gens_image_ = i2;

  (* image gen Color Claws *)
  gen_rand = builtin rem random ten;
  gen = builtin div gen_rand two;
  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten;

  i = builtin mul gens_image_ ten;
  i2 = builtin add i gen;
  gens_image_ = i2;

  (* color scheme *)
  gen_rand = builtin rem random ten3;
  (* moving to next digit *)
  random = builtin sub random gen_rand;
  random = builtin div random ten3;
  gen_rand = builtin div gen_rand four;
  i = builtin mul gens_image_ ten3;
  i2 = builtin add i gen_rand;
  gens_image_ = i2;

  (* mutagenImutable *)
  (* last gen no need to move to next digit *)
  gen_rand = builtin rem random ten3;
  gen_rand = builtin div gen_rand four;
  i = builtin mul gens_image_ ten3;
  i2 = builtin add i gen_rand;
  gens_image_ = i2;

  (* store gens to token *)
  token_gen_image[token_id] := gens_image_
end

procedure GenerateGens(token_id: Uint256, to: ByStr20)
  entropyNumber <- entropy;
  current_block <- & BLOCKNUMBER;

  random1 = random entropyNumber current_block to;
  random2 = random random1 current_block to;

  entropy := random2;

  token_gen_battle[token_id] := random1;
  GenerateImageGen token_id random2
end


(* DragonZIL procedures *)

(* Emit Errors *)
procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsContractOwner()
  is_contract_owner = builtin eq contract_owner _sender;
  match is_contract_owner with
  | True => 
  | False =>
    err = CodeNotContractOwner;
    ThrowError err
  end
end

procedure IsSelf(address_a: ByStr20, address_b: ByStr20)
  is_self = builtin eq address_a address_b;
  match is_self with
  | False =>
  | True =>
    err = CodeIsSelf;
    ThrowError err
  end
end

procedure IsTokenExists(token_id: Uint256)
  token_exist <- exists token_owners[token_id];
  match token_exist with
  | False =>
  | True =>
    err = CodeTokenExists;
    ThrowError err
  end
end

procedure IsMinter(address: ByStr20)
  is_minter <- exists minters[address];
  match is_minter with
  | True =>
  | False =>
    err = CodeIsNotMinter;
    ThrowError err
  end
end

procedure IsTokenOwner(token_id: Uint256, address: ByStr20)
  some_token_owner <- token_owners[token_id];
  match some_token_owner with
  | Some addr => 
    is_token_owner = builtin eq addr address;
    match is_token_owner with
    | True =>
    | False =>
      err = CodeNotTokenOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotFound;
    ThrowError err
  end
end

procedure IsApprovedForAll(token_owner: ByStr20, operator: ByStr20)
  is_operator_approved <- exists operator_approvals[token_owner][operator];
  match is_operator_approved with
  | True =>
  | False =>
    err = CodeNotApprovedForAll;
    ThrowError err
  end
end

procedure IsOwnerOrOperator(token_owner: ByStr20)
  is_owner = builtin eq _sender token_owner;
  is_approved_for_all <- exists operator_approvals[token_owner][_sender];
  is_authorised = orb is_owner is_approved_for_all;
  match is_authorised with
  | True =>
  | False =>
    err = CodeNotOwnerOrOperator;
    ThrowError err
  end
end

procedure IsOwnerOrOperatorOrApprovedSpender(token_id: Uint256, token_owner: ByStr20)
  is_owner = builtin eq _sender token_owner;
  is_approved_for_all <- exists operator_approvals[token_owner][_sender];
  some_token_approval <- token_approvals[token_id];
  is_approved = match some_token_approval with
    | None => False
    | Some approved_address => 
      builtin eq _sender approved_address
    end;
  is_approved_or_owner = orb is_owner is_approved;
  is_authorised = orb is_approved_or_owner is_approved_for_all;
  match is_authorised with
  | True =>
  | False =>
    err = CodeNotOwnerOrOperatorOrApprovedSpender;
    ThrowError err
  end
end

procedure IsApprovedSpenderOrOperator(token_id: Uint256, token_owner: ByStr20)
  some_token_approval <- token_approvals[token_id];
  is_approved = match some_token_approval with
    | None => False
    | Some approved_address => 
      builtin eq _sender approved_address
    end;
  is_operator <- exists operator_approvals[token_owner][_sender];
  is_authorised = orb is_approved is_operator;
  match is_authorised with
  | True =>
  | False =>
    err = CodeNotApprovedSpenderOrOperator;
    ThrowError err
  end
end

procedure UpdateTokenCount(operation: Operation, address: ByStr20)
  match operation with
  | Add =>
    some_to_count <- owned_token_count[address];
    new_to_count = 
      let current_count = get_bal some_to_count in
      builtin add current_count one;
    owned_token_count[address] := new_to_count
  | Sub =>
    some_from_count <- owned_token_count[address];
    new_from_count = 
      let current_count = get_bal some_from_count in
        let is_zero = builtin eq current_count zero in
          match is_zero with
          | True => zero
          | False => builtin sub current_count one
          end;
    owned_token_count[address] := new_from_count
  end
end

procedure Minting(token_id: Uint256, to: ByStr20)
  (* Add address stage. *)
  tokens_owner_stage[to][token_id] := default_stage;
  token_stage[token_id] := default_stage;
  (* Mint new non-fungible token *)
  token_owners[token_id] := to;
  (* Generate some uri for token. *)
  ChangeTokenURI token_id default_stage;
  (* Add to owner count *)
  UpdateTokenCount add_operation to;

  some_token_uri <- token_uris[token_id];
  match some_token_uri with
  | Some token_uri => 
    e = {
      _eventname: "MintSuccess";
      by: _sender;
      recipient: to;
      token_id: token_id;
      token_uri: token_uri
    };
    event e
  | None =>
  end
end

procedure Birth(token: Dragon)
  current_supply <- total_supply;
  current_count <- token_id_count;
  new_supply = builtin add current_supply one;
  (* Add to total_supply *)
  total_supply := new_supply;

  match token with
  | Dragon token_id owner stage token_uri gen_battle gen_image =>
    is_zero = builtin eq token_id zero;
    match is_zero with
    | True =>
      (* Initiate new_token_id *)
      new_token_id = builtin add current_count one;
      (* Add address stage. *)
      tokens_owner_stage[owner][new_token_id] := default_stage;
      token_stage[new_token_id] := default_stage;
      (* Mint new non-fungible token *)
      token_owners[new_token_id] := owner;
      (* Add to owner count *)
      UpdateTokenCount add_operation owner;
      (* Create token_uri for new_token_id *)
      ChangeTokenURI new_token_id default_stage;
      (* Add token gens battle *)
      token_gen_battle[new_token_id] := gen_battle;
      (* Add token gen image *)
      token_gen_image[new_token_id] := gen_image;
      (* Add to total_count *)
      token_id_count := new_token_id;
      some_token_uri <- token_uris[new_token_id];
      token_uri = option_str dummy_str some_token_uri;
      e = {
        _eventname: "BirthSuccess";
        by: _sender;
        recipient: owner;
        token_id: new_token_id;
        token_uri: token_uri
      };
      event e
    | False =>
      IsTokenExists token_id;
      (* Add address stage. *)
      tokens_owner_stage[owner][token_id] := stage;
      token_stage[token_id] := stage;
      (* Mint new non-fungible token *)
      token_owners[token_id] := owner;
      (* Add to owner count *)
      UpdateTokenCount add_operation owner;
      (* Add token_uri for token_id *)
      token_uris[token_id] := token_uri;
      (* Add token gens battle *)
      token_gen_battle[token_id] := gen_battle;
      (* Add token gen image *)
      token_gen_image[token_id] := gen_image;
      (* Change token_id_count *)
      is_biger = builtin lt current_count token_id;
      match is_biger with
      | True =>
        token_id_count := token_id
      | False =>
      end;
      e = {
        _eventname: "BirthSuccess";
        by: _sender;
        recipient: owner;
        token_id: token_id;
        token_uri: token_uri
      };
      event e
    end
  end
end

procedure MintFor(to: ByStr20)
  current_supply <- total_supply;
  current_count <- token_id_count;

  new_supply = builtin add current_supply one;
  new_count = builtin add current_count one;
  (* Initiate token_id *)
  token_id = new_count;

  GenerateGens token_id to;
  Minting token_id to;

  (* Add to total_supply *)
  total_supply := new_supply;
  (* Add to total_count *)
  token_id_count := new_count

end

procedure ChangeBattleGen(id_gen: IdBattleGenPair)
  match id_gen with
  | IdBattleGenPair token_id gen_battle =>
    token_exist <- exists token_gen_battle[token_id];
    match token_exist with
    | False =>
      err = CodeNotFound;
      ThrowError err
    | True =>
      option_gen_battle <- token_gen_battle[token_id];
      current_gen_battle = option_uint256 zero option_gen_battle;
      token_gen_battle[token_id] := gen_battle;

      e = {
        _eventname: "GensChangedSuccess";
        token_id: token_id;
        old_gen_battle: current_gen_battle;
        new_gen_battle: gen_battle
      };
      event e
    end
  end
end

(* Getter transitions *)

(* @dev: Get number of NFTs assigned to a token_owner *)
transition BalanceOf(address: ByStr20)
  some_bal <- owned_token_count[address];
  balance = get_bal some_bal;
  msg_to_sender = {
    _tag: "BalanceOfCallBack";
    _recipient: _sender;
    _amount: Uint128 0;
    balance: balance
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Get total supply of NFTs minted *)
transition TotalSupply()
  current_supply <- total_supply;
  msg_to_sender = {
    _tag: "TotalSupplyCallBack";
    _recipient: _sender;
    _amount: Uint128 0;
    total_supply: current_supply
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Get name of the NFTs *)
transition Name()
  msg_to_sender = {
    _tag: "NameCallBack";
    _recipient: _sender;
    _amount: Uint128 0;
    name: name
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Get name of the NFTs *)
transition Symbol()
  msg_to_sender = {
    _tag: "SymbolCallBack";
    _recipient: _sender;
    _amount: Uint128 0;
    symbol: symbol
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Get approved_addr for token_id *)
transition GetApproved(token_id: Uint256)
  some_token_approval <- token_approvals[token_id];
  match some_token_approval with
  | Some addr => 
    msg_to_sender = {
      _tag: "GetApprovedCallBack";
      _recipient: _sender;
      _amount: Uint128 0; 
      approved_addr: addr;
      token_id: token_id
    };
    msgs = one_msg msg_to_sender;
    send msgs
  | None => 
    err = CodeNotApproved;
    ThrowError err
  end
end

(* @dev: Get the token_uri of a certain token_id *)
transition GetTokenURI(token_id: Uint256)
  some_token_uri <- token_uris[token_id];
  match some_token_uri with
  | Some token_uri =>
    msg_to_sender = {
      _tag: "GetTokenURICallBack";
      _recipient: _sender;
      _amount: Uint128 0; 
      token_uri: token_uri
    };
    msgs = one_msg msg_to_sender;
    send msgs
  | None =>
    err = CodeNotFound;
    ThrowError err
  end
end

(* @dev: Check if a token_id is owned by a token_owner *)
transition CheckTokenOwner(token_id: Uint256, address: ByStr20)
  IsTokenOwner token_id address;
  msg_to_sender = {
    _tag: "IsTokenOwnerCallBack";
    _recipient: _sender;
    _amount: Uint128 0
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Check if address is operator for token_owner *)
transition CheckApprovedForAll(token_owner: ByStr20, operator: ByStr20)
  IsApprovedForAll token_owner operator;
  msg_to_sender = {
    _tag: "IsApprovedForAllCallBack";
    _recipient: _sender;
    _amount: Uint128 0
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* DragonZIL getters *)
transition GetStage(token_id: Uint256)
  some_token_stage <- token_stage[token_id];
  match some_token_stage with
  | Some stage =>
    msg_to_sender = {
      _tag: "GetStageCallBack";
      _recipient: _sender;
      _amount: Uint128 0;
      token_id: token_id;
      stage: stage
    };
    msgs = one_msg msg_to_sender;
    send msgs
  | None =>
    err = CodeNotFound;
    ThrowError err
  end
end

procedure GetDragon(token_id: Uint256)
  token_exist <- exists token_owners[token_id];

  match token_exist with
  | False =>
    err = CodeNotFound;
    ThrowError err
  | True =>
    some_token_owner <- token_owners[token_id];
    some_token_uri <- token_uris[token_id];
    some_token_gen_battle <- token_gen_battle[token_id];
    some_token_gen_image <- token_gen_image[token_id];
    some_token_stage <- token_stage[token_id];
    some_tmp <- tmp;

    dragon = build_dragon token_id some_token_owner some_token_uri some_token_gen_battle some_token_gen_image some_token_stage;
    new_tmp = Cons {Dragon} dragon some_tmp;
    tmp := new_tmp
  end
end

transition GetDragons(ids: List Uint256)
  forall ids GetDragon;

  dragons <- tmp;

  empty = Nil {Dragon};
  tmp := empty;

  msg_to_sender = {
    _tag: "GetDragonsCallBack";
    _recipient: _sender;
    _amount: Uint128 0;
    dragons: dragons
  };
  msgs = one_msg msg_to_sender;
  send msgs
end
(* DragonZIL getters *)

(* Interface transitions *)

(* DragonZIL transition *)
transition UpStage(token_id: Uint256)
  IsOwnerOrOperatorOrApprovedSpender token_id _sender;

  (* Check if token exists *)
  max_stage_of_token <- max_stage;
  some_owner <- token_owners[token_id];
  token_owner = option_address zero_address some_owner;
  some_token_stage <- tokens_owner_stage[token_owner][token_id];
  match some_token_stage with
    | Some stage => 
      one32 = Uint32 1;
      next_stage = builtin add stage one32;
      is_max = builtin lt max_stage_of_token next_stage;

      match is_max with
        | True =>
          err = CodeStageError;
          ThrowError err
        | False =>
          tokens_owner_stage[_sender][token_id] := next_stage;
          token_stage[token_id] := next_stage;

          ChangeTokenURI token_id next_stage;

          e = {
            _eventname: "TokenStageUpgrade";
            token_id: token_id;
            old_stage: stage;
            next_stage: next_stage
          };
          event e
      end
    | None =>
      err = CodeNotFound;
      ThrowError err
  end
end

transition ChangeCloud(new_cloud: String)
  IsContractOwner;

  cloud := new_cloud;

  e = {
    _eventname: "ChangedCloudURL";
    cloud: new_cloud
  };
  event e
end

transition ChangeImgFormat(new_format: String)
  IsContractOwner;

  format_img := new_format;

  e = {
    _eventname: "ChangeImageFormat";
    format_img: new_format
  };
  event e
end

transition ChangeBattleGens(id_gen_list: List IdBattleGenPair)
  IsMinter _sender;
  
  forall id_gen_list ChangeBattleGen
end

transition ConfigureStage(value: Uint32)
  IsContractOwner;

  stage <- max_stage;
  max_stage := value;
  e = {
    _eventname: "MaxStageChanged";
    old: stage;
    new: value
  };
  event e
end

transition GiveBirth(dragons: List Dragon)
  IsMinter _sender;

  forall dragons Birth
end
(* DragonZIL transition *)

(* @dev:    Add or remove approved minters. Only contract_owner can approve minters. *)
(* @param:  minter      - Address of the minter to be approved or removed            *)
transition ConfigureMinter(minter: ByStr20)
  IsContractOwner;
  some_minter <- minters[minter];
  match some_minter with
  | Some Dummy => 
    (* Remove minter *)
    delete minters[minter];
    e = {
      _eventname: "RemovedMinterSuccess";
      minter: minter
    };
    event e
  | None =>
    (* Add minter *)
    minters[minter] := verdad;
    e = {
      _eventname: "AddMinterSuccess";
      minter: minter
    };
    event e
  end
end

(* @dev:    Mint new tokens. Only minters can mint.           *)
(* @param:  to        - Address of the token recipient        *)
transition Mint(to: ByStr20)
  IsMinter _sender;
  
  MintFor to;
  
  msg_to_recipient = {
    _tag : "RecipientAcceptMint";
    _recipient : to;
    _amount : Uint128 0
  };
  msgs = one_msg msg_to_recipient;
  send msgs
end

transition BatchMint(onwers: List ByStr20)
  IsMinter _sender;

  forall onwers MintFor;
  
  own_head = @list_head ByStr20;
  option_to = own_head onwers;
  match option_to with
  | Some to =>
    msg_to_recipient = {
      _tag : "RecipientAcceptMint";
      _recipient : to;
      _amount : Uint128 0
    };
    msgs = one_msg msg_to_recipient;
    send msgs
  | None =>
    err = CodeListEmpty;
    ThrowError err
  end
end
(* @dev:    Burn existing tokens. Only token_owner or an operator can burn a NFT. *)
(* @param:  token_id - Unique ID of the NFT to be destroyed                       *)
transition Burn(token_id: Uint256)
  (* Check if token exists *)
  some_token_owner <- token_owners[token_id];
  match some_token_owner with
  | None =>
    err = CodeNotFound;
    ThrowError err
  | Some token_owner =>
    IsOwnerOrOperatorOrApprovedSpender token_id token_owner;
    (* Destroy existing token *)
    delete token_owners[token_id];
    delete token_approvals[token_id];
    delete token_uris[token_id];
    delete token_gen_battle[token_id];
    delete token_gen_image[token_id];
    delete tokens_owner_stage[token_owner][token_id];
    delete token_stage[token_id];
    (* Deduct from owned_token_count *)
    UpdateTokenCount sub_operation token_owner;
    (* Deduct from total_supply *)
    current_supply <- total_supply;
    new_supply = builtin sub current_supply one;
    total_supply := new_supply;
    e = {
      _eventname: "BurnSuccess";
      initiator: _sender;
      burn_address: token_owner;
      token_id: token_id
    };
    event e;
    msg_to_sender = {
      _tag: "BurnCallBack";
      _recipient: _sender;
      _amount: Uint128 0;
      initiator: _sender;
      burn_address: token_owner;
      token_id: token_id
    };
    msgs = one_msg msg_to_sender;
    send msgs
  end
end

(* @dev: Approves OR remove an address ability to transfer a given token_id *)
(* There can only be one approved_spender per token at any given time       *)
(* param: to       - Address to be approved for the given token_id          *)
(* param: token_id - Unique ID of the NFT to be approved                    *)
transition SetApprove(to: ByStr20, token_id: Uint256)
  some_token_owner <- token_owners[token_id];
  match some_token_owner with
  | None =>
    err = CodeNotFound;
    ThrowError err
  | Some token_owner =>
    IsOwnerOrOperator token_owner;
    is_approved <- exists token_approvals[token_id];
    match is_approved with
    | True =>
      (* Remove approved_spender *)
      delete token_approvals[token_id];
      e = {
        _eventname: "RemoveApprovalSuccess";
        initiator: _sender;
        removed_spender: to;
        token_id: token_id
      };
      event e;
      msg_to_sender = {
        _tag: "RemoveApprovalSuccessCallBack";
        _recipient: _sender;
        _amount: Uint128 0; 
        removed_spender: to;
        token_id: token_id
      };
      msgs = one_msg msg_to_sender;
      send msgs
    | False =>
      (* Add approved_spender *)
      token_approvals[token_id] := to;
      e = {
        _eventname: "AddApprovalSuccess";
        initiator: _sender;
        approved_spender: to;
        token_id: token_id
      };
      event e;
      msg_to_sender = {
        _tag: "AddApprovalSuccessCallBack";
        _recipient: _sender;
        _amount: Uint128 0; 
        approved_spender: to;
        token_id: token_id
      };
      msgs = one_msg msg_to_sender;
      send msgs
    end
  end
end

(* @dev: Sets or unsets an operator for the _sender       *)
(* @param: to - Address to be set or unset as an operator *)
transition SetApprovalForAll(to: ByStr20)
  IsSelf to _sender;
  is_operator <- exists operator_approvals[_sender][to];
  match is_operator with
  | False =>
    (* Add operator *)
    operator_approvals[_sender][to] := verdad;
    e = {
      _eventname: "AddApprovalForAllSuccess";
      initiator: _sender;
      operator: to
    };
    event e
  | True =>
    (* Remove operator *)
    delete operator_approvals[_sender][to];
    e = {
      _eventname: "RemoveApprovalForAllSuccess";
      initiator: _sender;
      operator: to
    };
    event e
  end;
  new_status = negb is_operator;
  msg_to_sender = {
    _tag: "SetApprovalForAllSuccessCallBack";
    _recipient: _sender;
    _amount: Uint128 0; 
    operator: to;
    status: new_status
  };
  msgs = one_msg msg_to_sender;
  send msgs
end

(* @dev: Transfer the ownership of a given token_id to another address. token_owner only transition. *)
(* @param: to       - Recipient address for the token                                                *)
(* @param: token_id - Unique ID of the NFT to be transferred                                         *)
transition Transfer(to: ByStr20, token_id: Uint256)
  IsSelf to _sender;
  IsTokenOwner token_id _sender;

  owner_stage <- tokens_owner_stage[_sender][token_id];

  match owner_stage with
  | None =>
    (* Token does not exists, return error code *)
    err = CodeNotFound;
    ThrowError err
  | Some stage =>
    (* Change token_owner for that token_id *)
    token_owners[token_id] := to;
    (* Delete tokenApproval entry for that token_id *)
    delete token_approvals[token_id];
    (* Remove old owner stage *)
    delete tokens_owner_stage[_sender][token_id];
    (* Set new owner stage. *)
    tokens_owner_stage[to][token_id] := stage;
    (* Subtract one from previous token owner count *)
    UpdateTokenCount sub_operation _sender;
    (* Add one to the new token owner count *)
    UpdateTokenCount add_operation to;
    e = {
      _eventname: "TransferSuccess";
      from: _sender;
      recipient: to;
      token_id: token_id
    };
    event e;
    msg_to_recipient = {
      _tag: "RecipientAcceptTransfer";
      _recipient: to;
      _amount: Uint128 0; 
      from: _sender;
      recipient: to;
      token_id: token_id
    };
    msg_to_sender = {
      _tag: "TransferSuccessCallBack";
      _recipient: _sender;
      _amount: Uint128 0; 
      from: _sender;
      recipient: to;
      token_id: token_id
    };
    msgs = two_msgs msg_to_recipient msg_to_sender;
    send msgs
  end
end

(* @dev: Transfer the ownership of a given token_id to another address. approved_spender or operator only transition. *)
(* @param: to       - Recipient address for the NFT                                                                   *)
(* @param: token_id - Unique ID of the NFT to be transferred                                                          *)
transition TransferFrom(to: ByStr20, token_id: Uint256)
  some_token_owner <- token_owners[token_id];
  match some_token_owner with
  | None =>
    err = CodeNotFound;
    ThrowError err
  | Some token_owner =>
    owner_stage <- tokens_owner_stage[token_owner][token_id];
    match owner_stage with
      | None =>
        (* Token does not exists, return error code *)
        err = CodeNotFound;
        ThrowError err
      | Some stage =>
        IsSelf to token_owner;
        IsApprovedSpenderOrOperator token_id token_owner;
        (* Change token_owner for that token_id *)
        token_owners[token_id] := to;
        (* Delete tokenApproval entry for that token_id *)
        delete token_approvals[token_id];
        (* Remove stage of tokensOwner *)
        delete tokens_owner_stage[token_owner][token_id];
        (* Subtract one from previous token owner count *)
        UpdateTokenCount sub_operation token_owner;
        (* Add one to the new token owner count *)
        UpdateTokenCount add_operation to;
        tokens_owner_stage[to][token_id] := stage;
        e = {
          _eventname: "TransferFromSuccess";
          from: token_owner;
          recipient: to;
          token_id: token_id
        };
        event e;
        msg_to_recipient = {
          _tag: "RecipientAcceptTransferFrom";
          _recipient: to;
          _amount: Uint128 0; 
          from: token_owner;
          recipient: to;
          token_id: token_id
        };
        msg_to_sender = {
          _tag: "TransferFromSuccessCallBack";
          _recipient: _sender;
          _amount: Uint128 0; 
          from: token_owner;
          recipient: to;
          token_id: token_id
        };
        msgs = two_msgs msg_to_recipient msg_to_sender;
        send msgs
    end
  end
end
