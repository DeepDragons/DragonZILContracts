scilla_version 0

import PairUtils
library ArenaLib

type Error =
  | CodeMinPrice

let ff = False
let tt = True

let zero_int256 = Int256 0

let zero256 = Uint256 0
let one256 = Uint256 1

let ten = Uint256 10
let factor0 = Uint256 100
let factor1 = Uint256 10000
let factor2 = Uint256 1000000
let factor3 = Uint256 100000000
let factor4 = Uint256 10000000000
let factor5 = Uint256 1000000000000
let factor6 = Uint256 100000000000000
let factor7 = Uint256 10000000000000000
let factor8 = Uint256 1000000000000000000
let factor9 = Uint256 100000000000000000000
let factor10 = Uint256 10000000000000000000000
let factor11 = Uint256 1000000000000000000000000
let factor12 = Uint256 100000000000000000000000000
let factor13 = Uint256 10000000000000000000000000000
let factor14 = Uint256 1000000000000000000000000000000
let factor15 = Uint256 100000000000000000000000000000000
let factor16 = Uint256 10000000000000000000000000000000000
let factor17 = Uint256 1000000000000000000000000000000000000
let factor18 = Uint256 100000000000000000000000000000000000000
let factor19 = Uint256 10000000000000000000000000000000000000000
let factor20 = Uint256 1000000000000000000000000000000000000000000
let factor21 = Uint256 100000000000000000000000000000000000000000000
let factor22 = Uint256 10000000000000000000000000000000000000000000000
let factor23 = Uint256 1000000000000000000000000000000000000000000000000
let factor24 = Uint256 100000000000000000000000000000000000000000000000000
let factor25 = Uint256 10000000000000000000000000000000000000000000000000000
let factor26 = Uint256 1000000000000000000000000000000000000000000000000000000
let factor27 = Uint256 100000000000000000000000000000000000000000000000000000000
let factor28 = Uint256 10000000000000000000000000000000000000000000000000000000000
let factor29 = Uint256 1000000000000000000000000000000000000000000000000000000000000
let factor30 = Uint256 100000000000000000000000000000000000000000000000000000000000000
let factor31 = Uint256 10000000000000000000000000000000000000000000000000000000000000000
let factor32 = Uint256 1000000000000000000000000000000000000000000000000000000000000000000
let factor33 = Uint256 100000000000000000000000000000000000000000000000000000000000000000000
let factor34 = Uint256 10000000000000000000000000000000000000000000000000000000000000000000000
let factor35 = Uint256 1000000000000000000000000000000000000000000000000000000000000000000000000
let factor36 = Uint256 100000000000000000000000000000000000000000000000000000000000000000000000000
let factor37 = Uint256 10000000000000000000000000000000000000000000000000000000000000000000000000000
let factor38 = Uint256 100000000000000000000000000000000000000000000000000000000000000000000000000000

let one_msg = 
  fun (msg : Message) => 
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let option_value =
  tfun 'A =>
  fun (default: 'A) =>
  fun (opt_val: Option 'A) =>
    match opt_val with
    | Some v => v
    | None => default
    end

let option_int256 = @option_value Int256

let blc_hash =
  fun (b0: Uint128) =>
  fun (b1: Uint128) =>
    let sum = builtin add b0 b1 in
      builtin keccak256hash sum

let random =
  fun (entropy: ByStr32) =>
  fun (blc: ByStr32) =>
  fun (block_number: BNum) =>
  fun (addr: ByStr20) =>
    let block_hash = builtin keccak256hash block_number in
    let str = builtin concat entropy addr in
    let str = builtin concat str block_hash in
    let str = builtin concat str blc in
      builtin keccak256hash str

(* Game control *)
let an_attack =
  fun (a: Uint256) =>
  fun (b: Uint256) =>
    let op_a = builtin to_int256 a in
    let op_b = builtin to_int256 b in
    let int_a = option_int256 zero_int256 op_a in
    let int_b = option_int256 zero_int256 op_b in
      builtin sub int_b int_a

let who_won =
  fun (d0: Uint256) =>
  fun (a0: Uint256) =>
  fun (d1: Uint256) =>
  fun (a1: Uint256) =>
    let attempt0 = an_attack a1 d0 in
    let attempt1 = an_attack a0 d1 in
    let diff = builtin lt attempt1 attempt0 in
      match diff with
      | True => Uint32 0
      | False => Uint32 1
      end

let get_gene =
  fun (last: Uint256) =>
  fun (genes: Uint256) =>
  fun (factor: Uint256) =>
  fun (decimal: Uint256) =>
    let gf = builtin rem genes factor in
    let gfd = builtin div gf decimal in
      builtin add gfd last

let get_attack_gene =
  fun (last: Uint256) =>
  fun (genes: Uint256) =>
  fun (factor: Uint256) =>
  fun (decimal: Uint256) =>
  fun (entropy: Uint256) =>
    let gene = get_gene last genes factor decimal in
    let crit = builtin div entropy factor in
    let crit = builtin rem crit ten in
      builtin add gene crit

let get_attack = 
  fun (entropy: Uint256) =>
  fun (genes: Uint256) =>
  fun (luck: Uint256) =>
    let g0 = builtin rem genes factor0 in
    let g1 = get_attack_gene g0 genes factor1 factor0 entropy in
    let g2 = get_attack_gene g1 genes factor2 factor1 entropy in
    let g3 = get_attack_gene g2 genes factor3 factor2 entropy in
    let g4 = get_attack_gene g3 genes factor4 factor3 entropy in
    let g5 = get_attack_gene g4 genes factor5 factor4 entropy in
    let g6 = get_attack_gene g5 genes factor6 factor5 entropy in
    let g7 = get_attack_gene g6 genes factor7 factor6 entropy in
    let g8 = get_attack_gene g7 genes factor8 factor7 entropy in
    let g9 = get_attack_gene g8 genes factor9 factor8 entropy in
    let g10 = get_attack_gene g9 genes factor10 factor9 entropy in
    let g11 = get_attack_gene g10 genes factor11 factor10 entropy in
    let g12 = get_attack_gene g11 genes factor12 factor11 entropy in
    let g13 = get_attack_gene g12 genes factor13 factor12 entropy in
    let g14 = get_attack_gene g13 genes factor14 factor13 entropy in
    let g15 = get_attack_gene g14 genes factor15 factor14 entropy in
    let g16 = get_attack_gene g15 genes factor16 factor15 entropy in
    let g17 = get_attack_gene g16 genes factor17 factor16 entropy in
    let g18 = get_attack_gene g17 genes factor18 factor17 entropy in
    let g19 = get_attack_gene g18 genes factor19 factor18 entropy in
    let entropy_number = builtin rem entropy ten in
    let is_luck = builtin lt entropy_number luck in
    match is_luck with
    | True =>
      let v = builtin mul g19 entropy_number in
      let v = builtin div v factor0 in
        builtin add g19 v
    | False => g19
    end

let get_defence =
  fun (genes: Uint256) =>
  fun (defence: Bool) =>
  fun (percent: Uint256) =>
    let g20 = get_gene zero256 genes factor20 factor19 in
    let g21 = get_gene g20 genes factor21 factor20 in
    let g22 = get_gene g21 genes factor22 factor21 in
    let g23 = get_gene g22 genes factor23 factor22 in
    let g24 = get_gene g23 genes factor24 factor23 in
    let g25 = get_gene g24 genes factor25 factor24 in
    let g26 = get_gene g25 genes factor26 factor25 in
    let g27 = get_gene g26 genes factor27 factor26 in
    let g28 = get_gene g27 genes factor28 factor27 in
    let g29 = get_gene g28 genes factor29 factor28 in
    let g30 = get_gene g29 genes factor30 factor29 in
    let g31 = get_gene g30 genes factor31 factor30 in
    let g32 = get_gene g31 genes factor32 factor31 in
    let g33 = get_gene g32 genes factor33 factor32 in
    let g34 = get_gene g33 genes factor34 factor33 in
    let g35 = get_gene g34 genes factor35 factor34 in
    let g36 = get_gene g35 genes factor36 factor35 in
    let g37 = get_gene g36 genes factor37 factor36 in
    match defence with
    | True =>
      let increase = builtin mul g37 percent in
      let increase = builtin div increase factor0 in
        builtin add g37 increase
    | False => g37
    end

(* Game control *)

contract ArenaContract
()

field entropy : ByStr32 = 0x16d4a835f774af976a5e5dbeed5bdbac2ae1b173e09d3f37e87833f32d0ffb83
field defender_percent : Uint256 = Uint256 30

procedure SafeCallback(bytes32: ByStr32)
  tag = builtin to_string bytes32;
  call_msg = {
    _tag: tag;
    _recipient: _sender;
    _amount: Uint128 0
  };
  msg = one_msg call_msg;
  send msg
end

transition Fighting(defender: Uint256, attacker: Uint256)
  current_block <- & BLOCKNUMBER;
  last_entropy <- entropy;
  percent <- defender_percent;

  blk0 = Uint128 123;
  bkl1 = Uint128 312;

  b32_blc = blc_hash blk0 bkl1;
  b32 = random last_entropy b32_blc current_block _sender;
  entropy_number = builtin to_uint256 b32;

  defender_luck = get_gene zero256 defender factor38 factor37;
  defender_attack = get_attack entropy_number defender defender_luck;
  defender_defence = get_defence defender tt percent;

  entropy_number = builtin div entropy_number attacker;

  attacker_luck = get_gene zero256 attacker factor38 factor37;
  attacker_attack = get_attack entropy_number attacker attacker_luck;
  attacker_defence = get_defence attacker ff percent;

  won = who_won
    defender_defence defender_attack
    attacker_defence attacker_attack;
  
  SafeCallback b32;
  e = {
    _eventname: "Won";
    won: won
  };
  event e
end
