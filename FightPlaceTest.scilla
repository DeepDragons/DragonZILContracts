scilla_version 0

import PairUtils ListUtils
(***************************************************)
(*               Associated library                *)
(***************************************************)
library FightPlaceDZT

(* DragonZIL types *)
(* Custom ADT storing - token_id, owner, stage, token_uri, token_gen_battle, token_gen_image *)
type Dragon =
| Dragon of Uint256 ByStr20 Uint32 String Uint256 Uint256

(* Custom ADT storing - token_id, token_gen_battle *)
type IdBattleGenPair =
| IdBattleGenPair of Uint256 Uint256
(* DragonZIL types *)


let one128 = Uint128 1
let zero128 = Uint128 0
let zero = Uint32 0
let tt = True

let one_msg =
  fun (msg : Message) =>
  let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let iota =
  fun (m : Uint32) =>
  fun (n : Uint32) =>
  fun (value : ByStr20) =>
    let m_lt_n = builtin lt m n in
    match m_lt_n with
    | True =>
        let delta = builtin sub n m in
        let delta_nat = builtin to_nat delta in
        let nil = Nil {ByStr20} in
        let acc_init = Pair {(List ByStr20) Uint32} nil n in
        let one = Uint32 1 in
        let step = fun (xs_n : Pair (List ByStr20) Uint32) => fun (ignore : Nat) =>
          match xs_n with
          | Pair xs n =>
              let new_n = builtin sub n one in
              let new_xs = Cons {ByStr20} value xs in
              Pair {(List ByStr20) Uint32} new_xs new_n
          end in
        let fold = @nat_fold (Pair (List ByStr20) Uint32) in
        let xs_m = fold step acc_init delta_nat in
        match xs_m with
        | Pair xs m => xs
        end
    | False => Nil {ByStr20}
    end

let one_drgnpair =
  fun (drgnpair : IdBattleGenPair) =>
    let nil_drgnpair = Nil {IdBattleGenPair} in
    Cons {IdBattleGenPair} drgnpair nil_drgnpair

(* Error events *)
type Error =
  | CodeInsufficientAmount
  | CodeWrongListLength
  | CodeAlreadyHadDragon
  | CodeNotAuthorised
  | CodeNoPubKey
  | CodeVerificationFailed
  | CodeUint32Overflow

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeInsufficientAmount => Int32 -1
      | CodeWrongListLength    => Int32 -2
      | CodeAlreadyHadDragon   => Int32 -3
      | CodeNotAuthorised      => Int32 -4
      | CodeNoPubKey           => Int32 -5
      | CodeVerificationFailed => Int32 -6
      | CodeUint32Overflow     => Int32 -7
      end
    in
    { _exception : "Error"; code : result_code }

(***************************************************)
(*             The contract definition             *)
(***************************************************)
contract FightPlaceDZT

(*  Parameters *)
(contract_owner: ByStr20,
 main_dzt : ByStr20)

(* Mutable fields *)
field incrementer: Uint128 = Uint128 0
field current_price: Uint128 = Uint128 1000000000000
field is_dragon_owner: Map ByStr20 Bool = Emp ByStr20 Bool

(* Emit Errors *)
procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsOwner()
  is_owner = builtin eq contract_owner _sender;

  match is_owner with
  | True =>
  | False =>
    err = CodeNotAuthorised;
    ThrowError err
  end
end

procedure MintDragons(onwers: List ByStr20)
  mint_call = {
    _tag: "BatchMint";
    _recipient: main_dzt;
    _amount: Uint128 0;
    onwers: onwers
  };
  msgs = one_msg mint_call;
  send msgs
end

transition setPrice(price: Uint128)
  IsOwner;

  current_price := price;
  e = {
    _eventname: "price_change_success";
    by: _sender
  };
  event e
end

transition setIncrementer(value: Uint128)
  IsOwner;

  incrementer := value;
  e = {
    _eventname: "incrementer_change_success";
    by: _sender
  };
  event e
end

transition Buy()
  price <- current_price;
  inc <- incrementer;

  dragon_count128 = builtin div _amount price;
  dragon_count32 = builtin to_uint32 dragon_count128;

  match dragon_count32 with
  | Some count =>
    is_zero = builtin eq count zero;

    match is_zero with
    | False =>
      owner_list = iota zero count _sender;
      accept;

      MintDragons owner_list;

      addition = builtin mul inc dragon_count128;
      new_price = builtin add price addition;

      current_price := new_price;

      dragons_cost = builtin mul dragon_count128 price;
      change = builtin sub _amount dragons_cost;
      is_zero_change = builtin eq change zero128;
      match is_zero_change with
      | False =>
        msg = {
          _tag: "";
          _recipient: _sender;
          _amount: change
        };
        msgs = one_msg msg;
        send msgs
      | True =>
      end
    | True =>
      err = CodeInsufficientAmount;
      ThrowError err
    end
  | None =>
    err = CodeUint32Overflow;
    ThrowError err
  end
end

transition ReturnFund ()
  IsOwner;
  bal <- _balance;

  e = {
    _eventname : "ReturnFundSuccessful";
    returned_amount: bal
  };
  event e;

  msg = {
    _tag: "";
    _recipient: contract_owner;
    _amount: bal
  };

  msgs = one_msg msg;
  send msgs
end

transition GetDragonsCallBack(dragons: List Dragon)
  (* update gens manually *)
  (* send message to update gens *)
  new_gen = Uint256 123123123;
  token_id = Uint256 3;
  id_gen = IdBattleGenPair token_id new_gen;

  id_gen_list = one_drgnpair id_gen;

  e = {
    _eventname : "GetDragonsCallBack";
    dragons: dragons;
    id_gen_list: id_gen_list
  };
  event e;

  changegens_call = {
    _tag: "ChangeBattleGens";
    _recipient: main_dzt;
    _amount: Uint128 0;
    id_gen_list: id_gen_list
  };
  msgs = one_msg changegens_call;
  send msgs

end

transition Fight (ids: List Uint256)
  (* get gens from 2 dragons *)

  e = {
    _eventname : "FightSuccessful";
    ids: ids
  };
  event e;

  getdragons_call = {
    _tag: "GetDragons";
    _recipient: main_dzt;
    _amount: Uint128 0;
    ids: ids
  };
  msgs = one_msg getdragons_call;
  send msgs
end
