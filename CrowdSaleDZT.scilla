scilla_version 0

import PairUtils ListUtils
(***************************************************)
(*               Associated library                *)
(***************************************************)
library CrowdSaleDZT

let one128 = Uint128 1
let one32 = Uint32 1
let tt = True

let one_msg = 
  fun (msg : Message) => 
  let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let list_length : forall 'A. List 'A -> Uint128 =
   tfun 'A =>
   fun (l : List 'A) =>
   let foldl = @list_foldl 'A Uint128 in
   let init = Uint128 0 in
   let one = Uint128 1 in
   let iter =
     fun (z : Uint128) =>
     fun (h : 'A) =>
       builtin add one z
   in
     foldl iter init l

let iota : Uint32 -> Uint32 -> List Uint32 =
  fun (m : Uint32) => fun (n : Uint32) =>
    let m_lt_n = builtin lt m n in
    match m_lt_n with
    | True =>
        let delta = builtin sub n m in
        let delta_nat = builtin to_nat delta in
        let nil = Nil {Uint32} in
        let acc_init = Pair {(List Uint32) Uint32} nil n in
        let one = Uint32 1 in
        let step = fun (xs_n : Pair (List Uint32) Uint32) => fun (ignore : Nat) =>
          match xs_n with
          | Pair xs n =>
              let new_n = builtin sub n one in
              let new_xs = Cons {Uint32} new_n xs in
              Pair {(List Uint32) Uint32} new_xs new_n
          end in
        let fold = @nat_fold (Pair (List Uint32) Uint32) in
        let xs_m = fold step acc_init delta_nat in
        match xs_m with
        | Pair xs m => xs
        end
    | False => Nil {Uint32}
    end

(* Error events *)
type Error =
  | CodeInsufficientAmount
  | CodeWrongListLength
  | CodeAlreadyHadDragon
  | CodeNotAuthorised
  | CodeNoPubKey
  | CodeVerificationFailed

let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | CodeInsufficientAmount => Int32 -1
      | CodeWrongListLength => Int32 -2
      | CodeAlreadyHadDragon => Int32 -3
      | CodeNotAuthorised => Int32 -4
      | CodeNoPubKey => Int32 -5
      | CodeVerificationFailed => Int32 -6
      end
    in
    { _exception : "Error"; code : result_code }

(***************************************************)
(*             The contract definition             *)
(***************************************************)
contract CrowdSaleDZT

(*  Parameters *)
(contract_owner: ByStr20,
 main_dzt : ByStr20)

(* Mutable fields *)
field incrementer: Uint128 = Uint128 0
field current_price: Uint128 = Uint128 1000000000000
field serverPubKey: Option ByStr33 = None {ByStr33}
field is_dragon_owner: Map ByStr20 Bool = Emp ByStr20 Bool

(* Emit Errors *)
procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure BuyOne(count: Uint32)
  is_approved_call = {
    _tag: "mint";
    _recipient: main_dzt;
    _amount: Uint128 0;
    to: _sender
  };
  msgs = one_msg is_approved_call;
  send msgs
end

transition setPubKey(pubk: ByStr33)
  is_owner = builtin eq contract_owner _sender;

  match is_owner with
  | False =>
    (* Token exists, return error code *)
    err = CodeNotAuthorised;
    ThrowError err
  | True =>
    tmp = Some {ByStr33} pubk;
    serverPubKey := tmp;
    e = {
      _eventname: "public_key_success";
      by: _sender
    };
    event e
  end
end

transition Buy()
  price <- current_price;
  inc <- incrementer;

  dragon_count128 = builtin div _amount price;
  dragon_count32 = builtin to_uint32 dragon_count128;

  match dragon_count32 with
   | Some count =>
    zero = Uint32 0;
    dumy_list = iota zero count;

    accept;

    forall dumy_list BuyOne;

    addition = builtin mul inc dragon_count128;
    new_price = builtin add price addition;

    current_price := new_price;
    is_dragon_owner[_sender] := tt
   | None =>
      (* We don't have a key-pair. *)
      err = CodeInsufficientAmount;
      ThrowError err
  end
end

transition AirDrop(address: ByStr20, signature: ByStr64)
  is_has <- is_dragon_owner[address];
  is_has_bool = match is_has with
    | None => False
    | Some val => val
  end;
  match is_has_bool with
    | True =>
      (* Address already had dragons, return error code *)
      err = CodeAlreadyHadDragon;
      ThrowError err
    | False =>
      pubk_o <- serverPubKey;
      match pubk_o with
      | Some pubk =>
        msg = builtin to_bystr address;
        sig = builtin schnorr_verify pubk msg signature;
        match sig with
        | True =>
          (* Verification successful*)
          is_dragon_owner[address] := tt;
          BuyOne one32
        | False =>
          (* Verification failed*)
          err = CodeVerificationFailed;
          ThrowError err
        end
      | None =>
        (* We don't have a key-pair. *)
        err = CodeNoPubKey;
        ThrowError err
      end
      
  end 
end

transition mintCallBack(recipient: ByStr20, token_id: Uint256, token_uri: String)
end
