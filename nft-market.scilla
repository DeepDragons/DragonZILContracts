scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import IntUtils BoolUtils
library MarketPlace

let one_msg = 
  fun (msg : Message) => 
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let two_msgs =
fun (msg1 : Message) =>
fun (msg2 : Message) =>
  let msgs_tmp = one_msg msg2 in
  Cons {Message} msg1 msgs_tmp

let three_msgs =
fun (msg1 : Message) =>
fun (msg2 : Message) =>
fun (msg3 : Message) =>
  let msgs_tmp = two_msgs msg2 msg3 in
  Cons {Message} msg1 msgs_tmp
  
(* Error events *)
type Error =
  | CodeSaleNotExist
  | CodeSaleExists
  | CodePaymentNotEqualAmount
  | CodeNotTokenOwner
  | CodeNotFound
  | CodeMarketplaceNotApproved
  | CodeNotContractOwner
  | CodeInvalidCommissionAmount
  | CodeInvalidRoyaltyAmount
  | CodeExcessCommissionAndRoyalty

let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | CodeSaleNotExist => Int32 -1
      | CodeSaleExists=> Int32 -2
      | CodePaymentNotEqualAmount => Int32 -3
      | CodeNotTokenOwner => Int32 -4
      | CodeNotFound => Int32 -5
      | CodeMarketplaceNotApproved => Int32 -6
      | CodeNotContractOwner => Int32 -7
      | CodeInvalidCommissionAmount => Int32 -8
      | CodeInvalidRoyaltyAmount => Int32 -9
      | CodeExcessCommissionAndRoyalty => Int32 -10
      end
    in
    { _exception : "Error"; code : result_code }
  
let zero = Uint128 0
let sale_bought_code  = Int32 1

(* Dummy user-defined ADT *)
type Unit =
| Unit

(* Sale is NFTAddress, Name, OwnerAddress, Price *)
type Sale =
| Sale of ByStr20 String ByStr20 Uint128


let get_val =
  fun (some_val: Option Uint128) =>
  match some_val with
  | Some val => val
  | None => zero
  end

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract MarketPlace
(
  contract_owner: ByStr20
)

(* Mutable fields *)

(* List of sales *)
field sales: Map ByStr20 (Map Uint256 Sale)
  = Emp ByStr20 (Map Uint256 Sale)

field commission_amount: Uint128 = Uint128 1
(**************************************)
(*             Procedures             *)
(**************************************)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure SaleExists(nftAddress: ByStr20, token_id: Uint256)
  some_sale <- sales[nftAddress][token_id];
  match some_sale with 
  | None => 
  | Some val =>
    err = CodeSaleExists;
    ThrowError err  
  end
end

(* Checks if commission amount is between 1-10000 representing 0.01% to 100% *)
procedure IsValidCommissionAmount(amount: Uint128)
  min_amount = Uint128 1;
  max_amount = Uint128 10000;
  less_or_equal_max = uint128_le amount max_amount;
  greater_or_equal_one = uint128_ge amount min_amount;
  is_valid_amount = andb less_or_equal_max greater_or_equal_one;
  match is_valid_amount with 
    | True => 
    | False =>
      err = CodeInvalidCommissionAmount;
      ThrowError err
  end
end

(* Checks if royalty amount is between 1-10000 representing 0.01% to 100% *)
procedure IsValidRoyaltyAmount(amount: Uint128)
  min_amount = Uint128 1;
  max_amount = Uint128 10000;
  less_or_equal_max = uint128_le amount max_amount;
  greater_or_equal_one = uint128_ge amount min_amount;
  is_valid_amount = andb less_or_equal_max greater_or_equal_one;
  match is_valid_amount with 
    | True => 
    | False =>
      err = CodeInvalidRoyaltyAmount;
      ThrowError err
  end
end

procedure IsValidCommissionAndRoyalty(royalty: Uint128, commission: Uint128)
  max_percentage = Uint128 10000;
  percentage = builtin add royalty commission;
  is_valid_percentage = builtin lt percentage max_percentage;
  match is_valid_percentage with
  | True => 
  | False =>
    err = CodeExcessCommissionAndRoyalty;
    ThrowError err
  end 
end
    
procedure IsContractOwner()
  is_contract_owner = builtin eq contract_owner _sender;
  match is_contract_owner with
  | True => 
  | False =>
    err = CodeNotContractOwner;
    ThrowError err
  end 
end

(*@dev Transfers an NFT owned by this contract to another address. *)
(*Returns true if the transfer succeeds. *)
(*@param nft_address - Address of NFT. *)
(*@param receiver - Address to transfer NFT to. *)
(*@param token_id - ID of token to transfer. *)
procedure transfer(nft_address: ByStr20, receiver: ByStr20, token_id: Uint256) 
  (* it will throw if transfer fails *)
  msg = {_tag: "Transfer"; _recipient: nft_address; _amount: Uint128 0; to: receiver; token_id: token_id};
  msgs = one_msg msg;
  send msgs
end

(* @dev Escrows the NFT, assigning ownership to this address. *)
(* Throws if the escrow fails.  *)
(* @param nft_address - Current owner address of token to escrow. *)
(* @param token_id - ID of token whose approval to verify. *)
procedure escrow(nft_address: ByStr20, token_id: Uint256) 
  (* it will throw if transfer fails *)
  msg = {_tag: "TransferFrom"; _recipient: nft_address; _amount: Uint128 0; to: _this_address; token_id: token_id};
  msgs = one_msg msg;
  send msgs
end

(***************************************)
(*             Transitions             *)
(***************************************)

(* @dev:    Change commission amount to be sent to contract_owner. Only contract_owner can change. *)
(* @param:  amount - commission percentage amount to be changed to *)
transition setCommission(amount: Uint128)
  IsContractOwner;
  IsValidCommissionAmount amount;
  commission_amount := amount;
  e = {_eventname: "setCommission"; amount: amount};
  event e
end


(* Must approve marketplace to transfer nft on behalf *)
transition approveMarketplace(nft_address: ByStr20, token_id: Uint256)
  (*Approve marketplace contract to transfer nft*)
  msg = {_tag: "SetApprove"; _recipient: nft_address; _amount: Uint128 0; to: _this_address; token_id: token_id};
  msgs = one_msg msg;
  send msgs
end

(* @dev Adds sale to marketplace *)
(* @param nft_address - Current owner address of token to escrow. *)
(* @param name - Name of item to sell *)
(* @param token_id - ID of token whose approval to verify. *)
(* @param price - Price of sale *)
(* @param nft_contract: token_owners - Map of token_id to token owner 
                        token_approvals - Map of token_id to approved token spender *)
transition addSale(nft_address: ByStr20, name: String, token_id: Uint256, price: Uint128, nft_contract: ByStr20 with contract
                    field token_owners : Map Uint256 ByStr20,
                    field token_approvals: Map Uint256 ByStr20 end)
  (*check if sender is owner of token *)
  some_token_owner <-& nft_contract.token_owners[token_id];
  match some_token_owner with
  | Some addr =>
    is_token_owner = builtin eq addr _sender;
    match is_token_owner with
    | True =>
      some_token_approval <-& nft_contract.token_approvals[token_id];
      match some_token_approval with 
      | Some addr =>
        is_marketplace_approved = builtin eq addr _this_address;
        (*check if marketplace is approved to transfer nft*)
        match is_marketplace_approved with 
        | True =>
          SaleExists nft_address token_id;
          (* creates sale *)
          newSale = Sale nft_address name _sender price;
          sales[nft_address][token_id]:= newSale;
          (* transfers ownership of token to contract_owner *)
          escrow nft_address token_id;
          (*emit SaleCreated event*)
          e = {_eventname : "SaleCreated"; nft_address: nft_address; name: name; token_id: token_id; price: price};
          event e
        | False =>
          err = CodeMarketplaceNotApproved;
          ThrowError err
        end
      | None =>
        err = CodeMarketplaceNotApproved;
        ThrowError err
      end
    | False =>
      err = CodeNotTokenOwner;
      ThrowError err 
    end
  | None =>
    err = CodeNotFound;
    ThrowError err 
  end
end

(* @dev Remove sale from marketplace. *)
(* @param nft_address - Current owner address of token to escrow. *)
(* @param token_id - ID of token whose approval to verify. *)
transition removeSale(nft_address: ByStr20, token_id: Uint256)
(*check if sale exists *)
  exist_sale <- sales[nft_address][token_id];
  match exist_sale with
  | Some s =>
    match s with
    | Sale addr name owner price =>
      (* check if sender is previous owner *)
      is_owner_sender = builtin eq owner _sender;
      match is_owner_sender with
      | True =>
        (* delete sale and transfer nft back to previous owner*)
        delete sales[nft_address][token_id];
        transfer nft_address _sender token_id;
        e = {_eventname : "SaleRemoved"; nft_address: nft_address; name: name; token_id: token_id; 
        price: price; owner: _sender};
        event e;
        sales_map <- sales[nft_address];
        match sales_map with
        | Some entry =>
          entry_size = builtin size entry;  
          zero = Uint32 0;
          is_empty = builtin eq entry_size zero;
          match is_empty with
          | True => 
            delete sales[nft_address]
          | False => 
          end
        | None => 
        end
      | False =>
        err = CodeNotTokenOwner;
        ThrowError err 
      end
    end
  | None => 
    err = CodeSaleNotExist;
    ThrowError err 
  end
end

(* @dev Buy sale from marketplace. *)
(* @param nft_address - Current owner address of token to escrow. *)
(* @param token_id - ID of token whose approval to verify. *)
(* @param nft_contract: royalty_amount - royalty percentage (range 0-10000 representing 0%-100%) *)
transition buySale(nft_address: ByStr20, token_id: Uint256, nft_contract: ByStr20 with contract
                    field royalty_amount : Uint128 end)
  zil_amount = _amount;
  temp_royalty <-& nft_contract.royalty_amount;
  temp_commission <- commission_amount;
  (* Check if royalty amount within 0.01% to 100% *)
  IsValidRoyaltyAmount temp_royalty;
  (* Check whether tax + royalty percentage > 100% *)
  IsValidCommissionAndRoyalty temp_royalty temp_commission;
  (* check if sale exists*)
  exist_sale <- sales[nft_address][token_id];
  match exist_sale with
  | Some s =>
    match s with
    | Sale addr name owner price =>
      (* check if zil sent equals price *)
      is_price_equal = builtin eq price zil_amount;
      match is_price_equal with
      | True =>
        accept;
        (* calculate nft owner cut *)
        percentage = Uint128 10000;
        zil_amount_div_percentage = builtin div zil_amount percentage;
        (*royalty cut to be given to nft contract owner*)
        royalty_cut = builtin mul zil_amount_div_percentage temp_royalty;
        (*commission cut to be given to marketplace contract owner*)
        commission_cut = builtin mul zil_amount_div_percentage temp_commission;
        sale_minus_royalty = builtin sub zil_amount royalty_cut;
        (*rest of amount to be given to previous owner*)
        sale_cut = builtin sub sale_minus_royalty commission_cut;
 
         (* transfer nft to sender *)
        transfer nft_address _sender token_id;
        (* remove sale from marketplace *)
        delete sales[nft_address][token_id];
        sales_map <- sales[nft_address];
        match sales_map with
        | Some entry => 
          entry_size = builtin size entry;  
          zero = Uint32 0;
          is_empty = builtin eq entry_size zero;
          match is_empty with
          | True => 
            delete sales[nft_address];
            (* transfer royalty_cut to nft contract owner *)
            transfer_royalty_msg = {_tag: "transferRoyalty"; _recipient: nft_address; _amount: royalty_cut};
            (* transfer commission_cut to nft contract owner *)
            transfer_commission_msg = {_tag: "transferCommission"; _recipient: contract_owner; _amount: commission_cut};
            (* transfer sale_cut to previous nft owner *)
            sale_cut_msg = {_tag: "saleCut"; _recipient: owner; _amount: sale_cut};
            msgs = three_msgs transfer_royalty_msg transfer_commission_msg sale_cut_msg;
            send msgs;
            e = {_eventname : "SaleBought"; nft_address: nft_address; name: name; token_id: token_id; price: price};
            event e
          | False => 
            (* transfer royalty_cut to nft contract owner *)
            transfer_royalty_msg = {_tag: "transferRoyalty"; _recipient: nft_address; _amount: royalty_cut};
            (* transfer commission_cut to nft contract owner *)
            transfer_commission_msg = {_tag: "transferCommission"; _recipient: contract_owner; _amount: commission_cut};
            (* transfer sale_cut to previous nft owner *)
            sale_cut_msg = {_tag: "saleCut"; _recipient: owner; _amount: sale_cut};
            msgs = three_msgs transfer_royalty_msg transfer_commission_msg sale_cut_msg;
            send msgs;
            e = {_eventname : "SaleBought"; nft_address: nft_address; name: name; token_id: token_id; price: price};
            event e
          end
        | None => 
        end
      | False =>
        err = CodePaymentNotEqualAmount;
        ThrowError err 
      end
    end
  | None => 
    err = CodeSaleNotExist;
    ThrowError err 
  end
end

(*empty callbacks*)
transition TransferSuccessCallBack(from: ByStr20, recipient: ByStr20, token_id: Uint256)
end

transition TransferFromSuccessCallBack(from: ByStr20, recipient: ByStr20, token_id: Uint256)
end

transition RecipientAcceptTransfer(from: ByStr20, recipient : ByStr20, token_id : Uint256)
end

transition RecipientAcceptTransferFrom(from: ByStr20, recipient : ByStr20, token_id : Uint256)
end

transition TransferRoyaltySuccessCallBack(nft_contract: ByStr20, royalty_amount: Uint128)
end 

transition IsTokenOwnerCallBack()
end

transition AddApprovalSuccessCallBack(approved_spender: ByStr20, token_id: Uint256)
end
