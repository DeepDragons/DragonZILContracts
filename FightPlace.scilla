scilla_version 0

import PairUtils ListUtils
(***************************************************)
(*               Associated library                *)
(***************************************************)
library FightPlace

let zero = Uint256 0
let one = Uint256 1
let two = Uint256 2
let ten = Uint256 10
let ten2 = Uint256 100
let ten3 = Uint256 1000
let ten20 = Uint256 100000000000000000000
let tt = True

let one_msg =
  fun (msg : Message) =>
  let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

(* Error events *)
type Error =
  | CodeNotAuthorised
  | CodeNoPubKey
  | CodeVerificationFailed
  | CodeUint32Overflow

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeNotAuthorised      => Int32 -1
      | CodeNoPubKey           => Int32 -2
      | CodeVerificationFailed => Int32 -3
      | CodeUint32Overflow     => Int32 -4
      end
    in
    { _exception : "Error"; code : result_code }

(***************************************************)
(*             The contract definition             *)
(***************************************************)
contract FightPlace

(*  Parameters *)
(contract_owner: ByStr20,
 main_dzt : ByStr20)

(* Mutable fields *)
field waiting_list: Map Uint256 ByStr20 = Emp Uint256 ByStr20
field owners_list: Map Uint256 ByStr20 = Emp Uint256 ByStr20

field entropy : Uint256 = Uint256 0

field d1_random_attack_fld : Uint256 = Uint256 0
field d1_random_defence_fld : Uint256 = Uint256 0
field d2_random_attack_fld : Uint256 = Uint256 0
field d2_random_defence_fld : Uint256 = Uint256 0
field random_luck_fld : Uint256 = Uint256 0

field winner_random_attack_fld  : Uint256 = Uint256 0
field winner_random_defence_fld  : Uint256 = Uint256 0
field loser_random_attack_fld  : Uint256 = Uint256 0
field loser_random_defence_fld  : Uint256 = Uint256 0

let random =
  fun (entropy: Uint256) =>
  fun (block_number: BNum) =>
    let entropy_hash = builtin keccak256hash entropy in
    let blockhash = builtin keccak256hash block_number in
    let ehash = builtin concat entropy_hash blockhash in
    let hash = builtin keccak256hash ehash in
      builtin to_uint256 hash

let get_gen_val =
  fun (gen: Uint256) =>
  fun (num: Uint256) =>
    let gen_str = builtin to_string gen in
    let num32 = builtin to_uint32 num in
    let idx = builtin mul num32 two in
    let val = substr gen_str num32 two in
      builtin to_uint256 val

(* Emit Errors *)
procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsContractOwner()
  is_contract_owner = builtin eq contract_owner _sender;
  match is_contract_owner with
  | True =>
  | False =>
    err = CodeNotAuthorised;
    ThrowError err
  end
end

procedure AfterFightDraw(token_id1: Uint256, token_id2: Uint256)
  random_luck <- random_luck_fld;
  (* 0.8 luck *)

(* first_token_id *)
(* some_token1_gen_battle *)
(* number1 of gen who played *)
(* number2 of gen who played *)
(* add 20% - control field *)

(* call change gen msg *)
end

procedure SetFldsRandWinLose (num_winner: Uint256)
(* DO WE NEED TMP VAR HERE??? *)
  match num_winner with
  | one
    d1ra <- d1_random_attack_fld;
    winner_random_attack_fld := d1ra;
    d1rd <- d1_random_defence_fld;
    winner_random_defence_fld := d1rd;
    d2ra <- d2_random_attack_fld;
    loser_random_attack_fld := d2ra;
    d2rd <- d2_random_defence_fld;
    loser_random_defence_fld := d2rd
  | two
    d2ra <- d2_random_attack_fld;
    winner_random_attack_fld := d2ra;
    d2rd <- d2_random_defence_fld;
    winner_random_defence_fld := d2rd;
    d1ra <- d1_random_attack_fld;
    loser_random_attack_fld := d1ra;
    d1rd <- d1_random_defence_fld;
    loser_random_defence_fld := d1rd
  end

  (* match num_winner with
  | one
    winner_random_attack_fld := d1_random_attack_fld;
    winner_random_defence_fld := d1_random_defence_fld;
    loser_random_attack_fld := d2_random_attack_fld;
    loser_random_defence_fld := d2_random_defence_fld
  | two
    winner_random_attack_fld := d2_random_attack_fld;
    winner_random_defence_fld := d2_random_defence_fld;
    loser_random_attack_fld := d1_random_attack_fld;
    loser_random_defence_fld := d1_random_defence_fld
  end *)
end

procedure AfterFightWinLose(num_winner: Uint256, token_id_winner: Uint256, gen_battle_winner: Uint256, token_id_loser: Uint256, gen_battle_loser: Uint256)
  (* call procedure to set winner and loser *)
  SetFldsRandWinLose num_winner;

  winner_random_attack <- winner_random_attack_fld;
  winner_random_defence <- winner_random_defence_fld;
  loser_random_attack <- loser_random_attack_fld;
  loser_random_defence <- loser_random_defence_fld;

  (* calculating gens *)
  (* last 2 digits - gen luck *)
  (* next 20 digits - gen attack *)
  (* next 20 digits - gen defence *)
  (* other are reserved *)
  winner_luck = builtin rem gen_battle_winner ten2;
  gen_battle_winner = builtin sub gen_battle_winner winner_luck;
  gen_battle_winner = builtin div gen_battle_winner ten2;

  winner_gen_attack = builtin rem gen_battle_winner ten20;
  gen_battle_winner = builtin sub gen_battle_winner winner_gen_attack;
  gen_battle_winner = builtin div gen_battle_winner ten20;

  winner_gen_defence = builtin rem gen_battle_winner ten20;
  gen_battle_winner = builtin sub gen_battle_winner winner_gen_defence;
  gen_battle_winner = builtin div gen_battle_winner ten20;

  loser_luck = builtin rem gen_battle_loser ten2;
  gen_battle_loser = builtin sub gen_battle_loser loser_luck;
  gen_battle_loser = builtin div gen_battle_loser ten2;

  loser_gen_attack = builtin rem gen_battle_loser ten20;
  gen_battle_loser = builtin sub gen_battle_loser loser_gen_attack;
  gen_battle_loser = builtin div gen_battle_loser ten20;

  loser_gen_defence = builtin rem gen_battle_loser ten20;
  gen_battle_loser = builtin sub gen_battle_loser loser_gen_defence;
  gen_battle_loser = builtin div gen_battle_loser ten20;


(* winner add 20% - control field *)

(* loser div to 2*)



(* assemble new gen_battle1, gen_battle2 *)
(* defence -> attack -> luck *)

(* gen_battle_winner mul add *)
(* gen_battle_loser mul add *)

(* call change gen msg *)
end



procedure GensMatch(token_id1: Uint256, gen_battle1: Uint256, token_id2: Uint256, gen_battle2: Uint256)
  (* generating random values *)
  entropyNumber <- entropy;
  current_block <- & BLOCKNUMBER;
  random = random entropyNumber current_block;
  entropy := random;

  d1_random_attack = builtin rem random ten;
  d1_random_attack_fld := d1_random_attack;
  random = builtin sub random d1_random_attack;
  random = builtin div random ten;

  d1_random_defence = builtin rem random ten;
  d1_random_defence_fld := d1_random_defence;
  random = builtin sub random d1_random_defence;
  random = builtin div random ten;

  d2_random_attack = builtin rem random ten;
  d2_random_attack_fld := d2_random_attack;
  random = builtin sub random d2_random_attack;
  random = builtin div random ten;

  d2_random_defence = builtin rem random ten;
  d2_random_defence_fld := d2_random_defence;
  random = builtin sub random d2_random_defence;
  random = builtin div random ten;

  random_luck_fld := builtin rem random ten2;



  (* calculating gens *)
  (* last 2 digits - gen luck *)
  (* next 20 digits - gen attack *)
  (* next 20 digits - gen defence *)
  (* other are reserved *)
  d1_luck = builtin rem gen_battle1 ten2;
  gen_battle1 = builtin sub gen_battle1 d1_luck;
  gen_battle1 = builtin div gen_battle1 ten2;

  d1_gen_attack = builtin rem gen_battle1 ten20;
  gen_battle1 = builtin sub gen_battle1 d1_gen_attack;
  gen_battle1 = builtin div gen_battle1 ten20;

  d1_gen_defence = builtin rem gen_battle1 ten20;

  d2_luck = builtin rem gen_battle2 ten2;
  gen_battle2 = builtin sub gen_battle2 d2_luck;
  gen_battle2 = builtin div gen_battle2 ten2;

  d2_gen_attack = builtin rem gen_battle2 ten20;
  gen_battle2 = builtin sub gen_battle2 d2_gen_attack;
  gen_battle2 = builtin div gen_battle2 ten20;

  d2_gen_defence = builtin rem gen_battle2 ten20;


  (* get gens patricipating in fights *)
  d1_attack = get_gen_val d1_gen_attack d1_random_attack;
  d1_defence = get_gen_val d1_gen_defence d1_random_defence;

  d2_attack = get_gen_val d2_gen_attack d2_random_attack;
  d2_defence = get_gen_val d2_gen_defence d2_random_defence;



  (* fight process - matching gens *)
  luck_bool_eq = builtin eq d1_luck d2_luck;
  luck_bool_neg = builtin lt d1_luck d2_luck;

  res1_bool_eq = builtin eq d1_defence d2_attack;
  (* true - win d2, false - win d1 *)
  res1_bool_neg = builtin lt d1_defence d2_attack;

  res2_bool_eq = builtin eq d2_defence d1_attack;
  (* true - win d1, false - win d2 *)
  res2_bool_neg = builtin lt d2_defence d1_attack;

  match res1_bool_eq with
  | True =>
    match res2_bool_eq with
    | True =>
      (* draw need check luck *)
      match luck_bool_eq with
      | True =>
        (* draw *)
        AfterFightDraw token_id1 token_id2
      | False =>
        match luck_bool_neg with
        | True =>
          (* d2 win *)
          AfterFightWinLose two token_id2 gen_battle2 token_id1 gen_battle1
        | False =>
          (* d1 win *)
          AfterFightWinLose one token_id1 gen_battle1 token_id2 gen_battle2
        end
      end
    | False =>
      match res2_bool_neg with
      | True =>
        (* d1 win *)
        AfterFightWinLose one token_id1 gen_battle1 token_id2 gen_battle2
      | False =>
        (* d2 win *)
        AfterFightWinLose two token_id2 gen_battle2 token_id1 gen_battle1
      end
    end
  | False =>
    match res1_bool_neg with
    | True =>
      (* round 1: d2 win  *)
      match res2_bool_eq with
      | True =>
        (* d2 win  *)
        AfterFightWinLose two token_id2 gen_battle2 token_id1 gen_battle1
      | False =>
        match res2_bool_neg with
        | True =>
          (* draw need check luck *)
          match luck_bool_eq with
          | True =>
            (* draw *)
            AfterFightDraw token_id1 token_id2
          | False =>
            match luck_bool_neg with
            | True =>
              (* d2 win *)
              AfterFightWinLose two token_id2 gen_battle2 token_id1 gen_battle1
            | False =>
              (* d1 win *)
              AfterFightWinLose one token_id1 gen_battle1 token_id2 gen_battle2
            end
          end
        | False =>
          (* d2 win  *)
          AfterFightWinLose two token_id2 gen_battle2 token_id1 gen_battle1
        end
      end
    | False =>
      (* round 1: d1 win  *)
      match res2_bool_eq with
      | True =>
        (* d1 win  *)
        AfterFightWinLose one token_id1 gen_battle1 token_id2 gen_battle2
      | False =>
        match res2_bool_neg with
        | True =>
          (* d1 win  *)
          AfterFightWinLose one token_id1 gen_battle1 token_id2 gen_battle2
        | False =>
          (* draw need check luck *)
          match luck_bool_eq with
          | True =>
            (* draw *)
            AfterFightDraw token_id1 token_id2
          | False =>
            match luck_bool_neg with
            | True =>
              (* d2 win *)
              AfterFightWinLose two token_id2 gen_battle2 token_id1 gen_battle1
            | False =>
              (* d1 win *)
              AfterFightWinLose one token_id1 gen_battle1 token_id2 gen_battle2
            end
          end
        end
      end
    end
  end

end


transition GetGens2CallBack(gen_battle1: Uint256, gen_battle2: Uint256)
(* it is call back, need to call GensMatch *)
end


transition Start(token_id: Uint256)
  (* check only main contract can place to wait list *)

  tokens_owner_stage[to][token_id] := default_stage;
  (* Mint new non-fungible token *)
  token_owners[token_id] := to;
end

transition Fight(who_token_id: Uint256, with_token_id: Uint256)


  e = {
    _eventname : "ReturnFundSuccessful";
    returned_amount: bal
  };
  event e;

  msg = {
    _tag: "";
    _recipient: contract_owner;
    _amount: bal
  };

  msgs = one_msg msg;
  send msgs

end
